# Cursor AI Rules

## Project Structure
- Frontend code is in Zig and compiles to WASM
- Backend code is in Python using AWS Lambda
- Keep frontend and backend code separate
- Use consistent naming conventions:
  - Frontend: camelCase for variables, PascalCase for types
  - Backend: snake_case for Python code

## Code Style
- Use 4 spaces for indentation in Python
- Use 4 spaces for indentation in Zig
- Keep line length under 100 characters
- Add docstrings to all Python functions
- Add comments to complex Zig code
- Add comments to any 3rd party API use

## Git Practices
- Commit messages should be clear and descriptive
- Use conventional commits format:
  - feat: for new features
  - fix: for bug fixes
  - docs: for documentation
  - refactor: for code refactoring
  - test: for adding tests

## Testing
- Write tests for all Python backend functions
- Test WASM compilation for frontend changes
- Include error handling in all API endpoints

## Documentation
- Keep README.md up to date
- Document all API endpoints
- Include setup instructions for new dependencies

## Security
- Never commit API keys or secrets
- Use environment variables for sensitive data
- Validate all user input
- Sanitize all database queries

## Performance
- Optimize WASM bundle size
- Use efficient DynamoDB queries
- Cache frequently accessed data
- Monitor Lambda execution times

## Accessibility
- Ensure frontend is keyboard navigable
- Include ARIA labels where needed
- Maintain good color contrast
- Support screen readers

## Error Handling
- Provide clear error messages
- Log errors appropriately
- Handle edge cases gracefully
- Include fallback behaviors 

## Cloud Architecture Plan

I am giving you the overall blueprint for TruthByte's backend infrastructure.

We are deploying via **CloudFormation templates** to manage all infrastructure related to Lambda functions, DynamoDB, API Gateway, IAM, and S3.

### Infrastructure Goals

- Use **least-privilege IAM roles** for Lambda functions:
  - Allow only required DynamoDB operations
  - Allow CloudWatch logging and optional X-Ray tracing

- Define **3 Lambda functions** (one for each backend task):
  - Explicitly set timeout and memory for each function
  - Use environment variables for:
    - DynamoDB table names
    - Log level
    - Future configuration values

- Connect each Lambda to **API Gateway**:
  - Add CORS support
  - Add a throttle policy to protect from buggy loops or malicious traffic

### DynamoDB Tables

Start with the following:
- `truthbyte-questions`
- `truthbyte-answers`
- `truthbyte-sessions`

These will be expanded later as needed.

### Lambda Deployment

Use S3 to store `.zip` artifacts for each Lambda. Include a local script (Makefile or `deploy.sh`) for packaging, uploading, and deploying via CloudFormation.

Example:

```bash
zip lambda-fetch-questions.zip fetch_questions.py
aws s3 cp lambda-fetch-questions.zip s3://truthbyte-artifacts/
aws cloudformation deploy \
  --template-file deploy/lambdas.yaml \
  --stack-name truthbyte-lambdas \
  --capabilities CAPABILITY_NAMED_IAM
# Repeat for other functions
```

This setup will support quick iteration and can be reused later in a GitHub Action pipeline.

### CloudFormation Template Structure

#### Organize CloudFormation templates as follows:

```
deploy/infra/
  - api.yaml           # API Gateway setup + route integration
  - lambdas.yaml       # All 3 lambdas + IAM roles
  - dynamodb.yaml      # Tables, indexes, etc.
  - logs.yaml          # Log groups, retention
  - backend-s3.yaml    # S3 bucket for housing the lambda code artifacts
  - frontend-s3.yaml   # S3 bucket for housing the wasm artifact
  - cloudfront.yaml    # Cloudfront Distribution for connecting a domain and certs
```

### CI/CD

- Scripts should be compatible with future GitHub Actions-based workflows.
- Bash and Powershell versions are maintained in parallel for users of each platform.
- These scripts like in deploy/scripts

## Auth Rules

- All Lambda handlers must check for a valid JWT in the `Authorization` header.
- JWTs are issued using `create_token(session_id: str)` and verified with `verify_token(token: str)` in `auth_utils.py`.
- Use `os.environ["JWT_SECRET"]` for signing.
- Unauthorized requests return `401 Unauthorized`.
- Tokens expire after 12 hours.
